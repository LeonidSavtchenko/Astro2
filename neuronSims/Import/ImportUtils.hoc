
load_file("StringUtils.hoc")
load_file("CheckUtils.hoc")
load_file("WidgetUtils.hoc")


// Create or clean up the temporary folder
// $s1 - The temporary folder relative path and name
// Returns 0/1 flag indicating success/error
func createOrCleanUpTempFolder() { local sysComRes, isError
    strdef tempFolderRelPathName, tempFolderPathName, sysCommandTempl, command
    
    tempFolderRelPathName = $s1
    
    sprint(tempFolderPathName, "%s%s", getcwd(), tempFolderRelPathName)
    sysCommandTempl = "if not exist \"%s\" (mkdir \"%s\") else (rmdir /s /q \"%s\" && mkdir \"%s\")"
    sprint(command, sysCommandTempl, tempFolderPathName, tempFolderPathName, tempFolderPathName, tempFolderPathName)
    sysComRes = system(command)
    isError = (sysComRes != 0)
    if (isError) {
        print "Import Failed: Cannot create or clean up the temporary folder"
    }
    return isError
}

// Load HOC file (first do some correction of the file, then load it, and then do some validation)
// $s1 - Input HOC file path and name
// $2 - 0/1 flag indicating whether to skip the temporary folder clean up stage
// Returns 0/1 flag indicating success/error
func loadHocFileWithCorrection() { local isNoCleanUpMode, len, isDendriteDefinitionFound, isSomaDefinitionFound, isReplacingSomaObjectWithArray localobj inFile, outFile, strFunc
    strdef inFilePathName, outFilePathNameTempl, outFilePathName, inLine, OriginalDendrite_str, outLine
    inFilePathName = $s1
    isNoCleanUpMode = $2
    
    if (!isNoCleanUpMode) {
        // Create the temporary folder if necessary
        isError = createOrCleanUpTempFolder("Import/temp_folder")
        if (isError) {
            return 1
        }
    }
    
    // Open input HOC file for reading
    inFile = new File()
    inFile.ropen(inFilePathName)
    
    // Create and open output HOC file for writing
    outFilePathNameTempl = "%sImport/temp_folder/last_corrected.hoc"
    sprint(outFilePathName, outFilePathNameTempl, getcwd())
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    strFunc = new StringFunctions()
    isSomaDefinitionFound = 0
    isDendriteDefinitionFound = 0
    isReplacingSomaObjectWithArray = 0
    
    while (1) {
        len = inFile.gets(inLine)
        if (len == -1) {
            break
        }
        
        outLine = inLine
        
        if (isReplacingSomaObjectWithArray && containsSubstring(inLine, "soma")) {
            // Replace "soma" with "soma[0]"
            replaceSubstring(inLine, "soma", "soma[0]", outLine)
        }
        
        if (!isSomaDefinitionFound && containsSubstring(inLine, "create") && containsSubstring(inLine, "soma")) {
            if (!containsSubstring(inLine, "soma[")) {
                // Replace "create*soma" with "create*soma[1]"
                replaceSubstring(inLine, "soma", "soma[1]", outLine)
                
                isReplacingSomaObjectWithArray = 1
                
                // For the case if we immediately hit the next IF condition
                inLine = outLine
            }
            
            isSomaDefinitionFound = 1
        }
        
        if (!isDendriteDefinitionFound && containsSubstring(inLine, "create") && containsSubstring(inLine, "dendrite[")) {
            // Read the "dendrite" array size
            strFunc.tail(inLine, "dendrite\\[", OriginalDendrite_str)
            strFunc.head(OriginalDendrite_str, "\\]", OriginalDendrite_str)
            
            // Define OriginalDendrite, NumberDendrites and SeedNumber in the output file
            outFile.printf("OriginalDendrite=%s\n", OriginalDendrite_str)
            outFile.printf("NumberDendrites=OriginalDendrite+2*(OriginalDendrite-1)\n")
            outFile.printf("SeedNumber=OriginalDendrite-1\n")
            
            // Replace the number with the variable in the "dendrite" array definition
            replaceSubstring(inLine, OriginalDendrite_str, "NumberDendrites", outLine)
            
            isDendriteDefinitionFound = 1
        }
        
        outFile.printf("%s", outLine)
    }
    
    outFile.close()
    inFile.close()
    
    load_file(outFilePathName)
    
    if (isUndefined("soma")) {
        print "Import Failed: The imported file does not define \"soma\" object"
        return 1
    }
    
    if (isUndefined("dendrite")) {
        print "Import Failed: The imported file does not define \"dendrite\" array"
        return 1
    }
    
    if (isUndefined("OriginalDendrite") || isUndefined("NumberDendrites") || isUndefined("SeedNumber")) {
        print "Import Failed: At least one of the following variables is not defined: OriginalDendrite, NumberDendrites, SeedNumber"
        return 1
    }
    
    return 0
}

// Import SWC or any other file supported by NLMorphologyConverter
// $s1 - Input file path and name
// $2 - 0/1 flag indicating whether to skip the temporary folder clean up stage
// Returns 0/1 flag indicating success/error or -1 if waiting for user input
func loadSwcOrOtherFile() { local isNoCleanUpMode, isError, isSomaMissing, sysComRes
    strdef inFilePathName, defaultUserChoiceHocCommand, appPathNameTempl, appPathName, outFilePathNameTempl, outFilePathName, extraArgTempl, extraArg, sysCommandTempl, command
    
    inFilePathName = $s1
    isNoCleanUpMode = $2
    
    if (userChoiceForSomaSphereDiam == -1) {
        isError = checkIfSomaIsMissingInThisGeometryFile(inFilePathName, isNoCleanUpMode, &isSomaMissing)
        if (isError) {
            return 1
        }
        
        if (isSomaMissing) {
            defaultUserChoiceHocCommand = "userChoiceForSomaSphereDiam = 10"
            
            // Ask user to make a choice to insert proper soma
            vBoxSomaInsertion = new VBox()
            vBoxSomaInsertion.intercept(1)
            xpanel("Soma insertion")
            xlabel("The input geometry file does not define soma. But it is required for this simulation.")
            xlabel("We will create soma as a ball of diameter \"d\" and connect it to the first dendrite.")
            xlabel("Please specify the input cell type:")
            xradiobutton("Astrocyte (d = 10 um)", defaultUserChoiceHocCommand, 1)
            xradiobutton("Neuron (d = 15 um)", "userChoiceForSomaSphereDiam = 15")
            xbutton("OK", "somaInsertionWidgetOkHandler()")
            xpanel()
            vBoxSomaInsertion.dismiss_action("somaInsertionWidgetDismissHandler()")
            vBoxSomaInsertion.intercept(0)
            vBoxSomaInsertion.map("Soma insertion", 550, 350, -1, -1)
            
            // In case if user does not touch radiobuttons, and just clicks "OK"
            execute(defaultUserChoiceHocCommand)
            
            // Unfortunately, we have to exit all the call stack now even though user is still making a choice
            // The "OK" button handler will repeat the top level call again
            return -1
        }
    }
    
    if (!isNoCleanUpMode) {
        // Create the temporary folder if necessary
        isError = createOrCleanUpTempFolder("Import/temp_folder")
        if (isError) {
            return 1
        }
    }
    
    // Convert the selected file to HOC with NLMorphologyConverter and save to the temporary folder
    appPathNameTempl = "%sImport/3rdParty/NLMorphologyConverter/NLMorphologyConverter.exe"
    sprint(appPathName, appPathNameTempl, getcwd())
    outFilePathNameTempl = "%sImport/temp_folder/last_converted.hoc"
    sprint(outFilePathName, outFilePathNameTempl, getcwd())
    if (userChoiceForSomaSphereDiam != -1) {
        extraArgTempl = "--forceSphereSoma %g"
        sprint(extraArg, extraArgTempl, userChoiceForSomaSphereDiam)
    } else {
        extraArg = ""
    }
    sysCommandTempl = "call \"%s\" \"%s\" \"%s\" NeuronHOC %s"
    sprint(command, sysCommandTempl, appPathName, inFilePathName, outFilePathName, extraArg)
    sysComRes = system(command)
    if (sysComRes != 0) {
        // Just for sanity. Actually, NLMorphologyConverter does not return error codes, but rather prints a message and creates a minimal output file
        print "Import Failed: Cannot convert the file to HOC format with NLMorphologyConverter"
        return 1
    }
    
    isError = loadHocFileWithCorrection(outFilePathName, 1)
    
    return isError
}

// Import SWC file from ZIP archive downloaded from NeuroMorpho.org
// $s1 - Input ZIP file path and name
// Returns 0/1 flag indicating success/error or -1 if waiting for user input
func loadSwcFileFromZipArchive() { local isError, status, sysComRes
    strdef inZipFilePathName, appPathNameTempl, appPathName, outFolderPathNameTempl, outFolderPathName, sysCommandTempl, command, swcFilePathNameTempl, swcFilePathName
    
    inZipFilePathName = $s1
    
    outFolderPathNameTempl = "%sImport/temp_folder/last_unzipped"
    sprint(outFolderPathName, outFolderPathNameTempl, getcwd())
    
    if (!isRepeatedCall) {
        // Create the temporary folders if necessary
        isError = createOrCleanUpTempFolder("Import/temp_folder")
        if (isError) {
            return 1
        }
        isError = createOrCleanUpTempFolder("Import/temp_folder/last_unzipped")
        if (isError) {
            return 1
        }
        
        // Unzip the selected archive with 7-Zip and save to the temporary folder
        appPathNameTempl = "%sImport/3rdParty/7-Zip/7z.exe"
        sprint(appPathName, appPathNameTempl, getcwd())
        sysCommandTempl = "call \"%s\" e \"%s\" -o\"%s\" > NUL 2> NUL"
        sprint(command, sysCommandTempl, appPathName, inZipFilePathName, outFolderPathName)
        sysComRes = system(command)
        if (sysComRes != 0) {
            print "Import Failed: Cannot unzip the archive with 7-Zip"
            return 1
        }
        
        // Rename the file *.CNG.swc to input_file.swc
        sysCommandTempl = "cd \"%s\" && ren *.CNG.swc input_file.swc 2> NUL"
        sprint(command, sysCommandTempl, outFolderPathName)
        sysComRes = system(command)
        isError = (sysComRes != 0)
        if (isError) {
            // Maybe just more than one swc-file in the archive, so only the first one is renamed successfully
            // print "Import Failed: Cannot rename the input SWC file"
            isError = 0
        }
    }
    
    swcFilePathNameTempl = "%s/input_file.swc"
    sprint(swcFilePathName, swcFilePathNameTempl, outFolderPathName)
    status = loadSwcOrOtherFile(swcFilePathName, 1)
    
    return status
}

// Import a file into Astro
// $s1 - HOC command to repeat the top level call once again
// Returns 0/1 flag indicating success/error or -1 if waiting for user input
func loadHocOrSwcOrZipOrOtherFile() { local isError, status localobj file
    strdef filePathName, fileExt
    
    topLevelCallHocCommand = $s1
    
    if (!isRepeatedCall) {
        file = new File()
        file.chooser("r", "Load", "*.*", "Load", "Cancel", getcwd())
        isError = (file.chooser() == 0)
        if (isError) {
            print "File wasn't selected"
            return 1
        }
        
        filePathName = file.getname
        userChoiceForInputFilePathName = filePathName
    } else {
        filePathName = userChoiceForInputFilePathName
    }
    
    getFileExt(filePathName, fileExt)
    
    if (stringsEqual(fileExt, "hoc") || stringsEqual(fileExt, "HOC")) {
        if (checkIfThisHocFileNeedsCorrection(filePathName)) {
            status = loadHocFileWithCorrection(filePathName, 0)
        } else {
            // Just for sanity
            status = createOrCleanUpTempFolder("Import/temp_folder")
            if (status) {
                return 1
            }
            
            load_file(filePathName)
        }
    } else {
        if (unix_mac_pc() != 3) {
            print "Import Failed: This file type can be imported only on Windows"
            return 1
        }
        if (stringsEqual(fileExt, "zip") || stringsEqual(fileExt, "ZIP")) {
            status = loadSwcFileFromZipArchive(filePathName)
        } else {
            status = loadSwcOrOtherFile(filePathName, 0)
        }
    }
    
    if (status != 0) {
        return status
    }
    
    showSelectedGeometry()
    
    return 0
}
